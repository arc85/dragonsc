ls
ls()
drag.conf
library(caret)
load('~/Desktop/ser_drag_confus_matrices.19.07.09.RData')
drag.conf
ser.conf
rnorm(1,mean=0,sd=1)
set.seed(-0.6)
library(caret)
load('~/Desktop/ser_drag_confus_matrices.19.07.09.RData')
ls
ls()
drag.conf
ser.clust
ls()
ser.conf
input.params
load("/Users/arc85/Desktop/ser_drag_confus_matrices.19.07.09.RData")
library(caret)
load("/Users/arc85/Desktop/ser_drag_confus_matrices.19.07.09.RData")
res1 <- sapply(drag.conf,function(x) x$overall)[1,]#
res2 <- sapply(ser.conf,function(x) x$overall)[1,]#
mean(res1)#
mean(res2)
boxplot(res1,res2)
wilcox.test(res1,res2)
plot(res1,res2)
barplot(res1,res2)
boxplot(res1,res2)
library(Seurat)
?FindClusters()
length(res1)
test <- function(x+y)
test <- function(x,y) {x+y}
test(1,5)
res <- Sys.time(blah <- test(1,5))
res <- Sys.time(test(1,5))
res <- systme.time(test(1,5))
res <- system.time(test(1,5))
res
res <- system.time(blah <- test(1,5))
blah
res <- system.time(blah <- test(1,5))$elapsed
res$elapsed
str(res)
res[3]
library(Seurat)
library(daGMM)
help(package='daGMM')
library(rmarkdown)
?render
library(Seurat)
library(rmarkdown)
render("~/Desktop/DRAGON_markdown.html",output_format="pdf")
render("~/Desktop/DRAGON_markdown.html",output_format="pdf_document")
library(pdflatex)
install.packages("pdflatex")
render("~/Desktop/DRAGON_markdown.html",output_format="pdf_document")
install.packages("latexpdf")
render("~/Desktop/DRAGON_markdown.html",output_format="pdf_document")
library(dragon)
help(package="dragon")
library(foreach)
install.packages("foreach")
q()
remove.pacakges("daGMM")
remove.pacakge("daGMM")
remove.packages("daGMM")
install.packages("~/Desktop/daGMM_parallel_19.01.16_current")
install.packages("~/Desktop/daGMM_parallel_19.01.16_current",rep="local")
install.packages("~/Desktop/daGMM_parallel_19.01.16_current",rep=NULL,type="source")
library(daGMM)
q()
source("http://bit.ly/archived-seurat")
if (!requireNamespace("BiocManager", quietly = TRUE))#
    install.packages("BiocManager")#
#
BiocManager::install("splatter")
install.packages("devtools")
norm1 <- dnorm(100)
norm2 <- dnorm(100,mean=2,sd=0.5)
test1 <- dnorm(1)
test1 <- dnorm(50)
test2 <- dnorm(50,mean=2,sd=0.5)
rand <- sample(100,1,replace=F)
rand
rand <- sample(100,100,replace=F)
rand
samp <- c(test1,test2)
samp <- samp[rand]
samp
test1 <- dnorm(50)#
test2 <- dnorm(50,mean=2,sd=0.5)
test1
norm1 <- dnorm(x=100)
norm1
norm1 <- dnorm(seq(1,100,1))
norm1
norm1 <- dnorm(seq(1,100,1),mean=0,sd=1)
norm1
norm1 <- dnorm(rep(1,100,1),mean=0,sd=1)
norm1
norm1 <- rnorm(100,mean=0,sd=1)
norm2 <- dnorm(100,mean=2,sd=0.5)
test1 <- rnorm(10)
norm2 <- rnorm(100,mean=2,sd=0.5)
test2 <- rnorm(10,mean=2,sd=0.5)
samp <- c(test1,test2)
samp <- samp[rand]
samp
norm1 <- rnorm(100,mean=0,sd=1)#
norm2 <- rnorm(100,mean=2,sd=0.5)
test1 <- rnorm(10)#
test2 <- rnorm(10,mean=2,sd=0.5)#
#
rand <- sample(100,100,replace=F)#
#
samp <- c(test1,test2)#
samp <- samp[rand]
samp
norm1 <- rnorm(100,mean=0,sd=1)
norm1
norm2
test1 <- rnorm(10)
test1
test2 <- rnorm(10,mean=2,sd=0.5)
test2
samp <- c(test1,test2)
samp
rand <- sample(20,20,replace=F)
rand
samp <- c(test1,test2)
samp <- samp[rand]
samp
norm3 <- rnorm(100,mean=3,sd=2)
test3 <- rnorm(10,mean=3,sd=2)
library(splatter)#
library(daGMM) #update to dragon later#
library(Seurat)#
#
#Create parameters and simulate data#
sc.params <- newSplatParams(nGenes=1000,batchCells=5000)#
sim.groups <- splatSimulate(params=sc.params,method="groups",group.prob=c(0.20,0.30,0.25,0.25),de.prob=c(0.1,0.2,0.3,0.2),verbose=F)#
sim.groups#
#
ser <- CreateSeuratObject(raw.data=assays(sim.groups)$counts)#
#
#Normal Seurat workflow#
ser <- NormalizeData(ser)#
ser <- ScaleData(ser)#
ser@var.genes <- rownames(ser@raw.data)#
#We will pretend like the 1000 simulated genes are the "variable genes",#
#and we will skip FindVariableGenes from Seurat#
ser <- RunPCA(ser)
pcs.for.dragon <- ser@dr$pca@cell.embeddings[,1:5]#
tsne.for.dragon <- ser@dr$tsne@cell.embeddings[,1:2]#
#
#The starting temperate should be a bit below the criterion for splitting two clusters, i.e. 2 times the first eigenvalue of the matrix#
est.temp <- eigen(cov(pcs.for.dragon))$values[[1]]*2
est.temp
init <- initialize.gmm(pcs.for.dragon,est.temp,num.cores=2)
init <- initialize.gmm(pcs.for.dragon,est.temp,num.cores=1)
names(init)
tsne.for.dragon <- ser@dr$tsne@cell.embeddings[,1:2]
ser <- RunTSNE(ser,dims.use=1:5)
tsne.for.dragon <- ser@dr$tsne@cell.embeddings[,1:2]
em_results <- expect_max(ps.for.dragon,tsne.for.dragon,clusters=init[["clusters"]],init[["maximization"]],max.iterations,delta.log.likelihood,decay.step[i,2],num.cores=1)
em_results <- expect_max(ps.for.dragon,tsne.for.dragon,clusters=init[["clusters"]],init[["maximization"]],max.iterations=20,delta.log.likelihood=1e-6,decay.step=est.temp,num.cores=1)
em_results <- expect_max(ps.for.dragon,tsne.for.dragon,clusters=init[["clusters"]],init[["maximization"]],max.iterations=20,delta.log.li=1e-6,temp=est.temp,num.cores=1)
em_results <- expect_max(pcs.for.dragon,tsne.for.dragon,clusters=init[["clusters"]],init[["maximization"]],max.iterations=20,delta.log.li=1e-6,temp=est.temp,num.cores=1)
parameter.estimates <- em_results[["maximization"]]
parameter.estimates
parameter.estimates[[1]]$cov
length(parameter.estimates)
res <- vector()
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pca.components[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pca.components),i)#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pca.components),i)#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)#
}
i
1:nrow(pcs.for.dragon)
mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),1)
mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),1:2)
mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),1)
mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),2)
res1 <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),1)
res2 <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),2)
identical(res1,res2)
res1[1:10]
res2[1:10]
res2[50:55]
res1[50:55]
res2 <- mapply(function(x) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[1]]$mu,parameter.estimates[[1]]$cov),1:nrow(pcs.for.dragon))
res2[1:10]
res2 <- mapply(function(x) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[2]]$mu,parameter.estimates[[2]]$cov),1:nrow(pcs.for.dragon))
res2[1:10]
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon))#
}
1:length(parameter.estimates)
res <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),1:2)
res[[1]]
str(res)
identical(res1,res)
identical(res2,res)
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)#
}
length(res)
res <- vector()
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)#
}
length(res)
res
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)#
}
res
i
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,i) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[i]]$mu,parameter.estimates[[i]]$cov),1:nrow(pcs.for.dragon),i)#
}
res
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),x=1:nrow(pcs.for.dragon),y=i)#
}
mahalanobis(pcs.for.dragon[1,],parameter.estimates[[1]]$mu,parameter.estimates[[1]]$cov)
mahalanobis(pcs.for.dragon[1:nrow(pcs.for.dragon),],parameter.estimates[[1]]$mu,parameter.estimates[[1]]$cov)
mahalanobis(pcs.for.dragon[1:nrow(pcs.for.dragon),],parameter.estimates[[1]]$mu,parameter.estimates[[1]]$cov)[1]
mahalanobis(pcs.for.dragon[1:nrow(pcs.for.dragon),],parameter.estimates[[1]]$mu,parameter.estimates[[1]]$cov)[2]
mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),x=1:nrow(pcs.for.dragon),y=1:2)
mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),x=1:nrow(pcs.for.dragon),y=1:2,SIMPLIFY=F)
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),x=1:nrow(pcs.for.dragon),y=i)#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[1:nrow(pcs.for.dragon),],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),y=i)#
}
i <- 1
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),x=1:nrow(pcs.for.dragon),y=1)
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),x=1:nrow(pcs.for.dragon),y=i)#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),x=1:nrow(pcs.for.dragon))#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon))#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon).1:2)#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),1:2)#
}
res[[i]] <- mapply(function(x) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[1]]$mu,parameter.estimates[[1]]$cov),1:nrow(pcs.for.dragon))#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[1]]$mu,parameter.estimates[[1]]$cov),1:nrow(pcs.for.dragon))#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(mahalanobis(pcs.for.dragon[1:nrow(pcs.for.dragon),],parameter.estimates[[1]]$mu,parameter.estimates[[1]]$cov),)#
}
res <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),1:2)
length(res)
res1 <- mapply(function(x) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[1]]$mu,parameter.estimates[[1]]$cov),1:nrow(pcs.for.dragon))
res2 <- mapply(function(x) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[2]]$mu,parameter.estimates[[2]]$cov),1:nrow(pcs.for.dragon))
identical(res1,res2)
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(y,x) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),i,1:nrow(pcs.for.dragon))#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)#
}
parameter.estimates[[y]]$mu
parameter.estimates[[1]]$mu
parameter.estimates[[2]]$mu
parameter.estimates[[2]]$cov
parameter.estimates[[1]]$cov
mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)
res <- vector()#
#
for (i in 1:length(parameter.estimates)) {#
res[,i] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)#
}
res <- matrix(data=NA,ncol=2)
for (i in 1:length(parameter.estimates)) {#
res[,i] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)#
}
res[,i] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)
mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)
res <- matrix(data=NA,nrow=5000,ncol=2)
for (i in 1:length(parameter.estimates)) {#
res[,i] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)#
}
dim(res)
res <- vector("")
res <- vector()
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i,SIMPLIFY=F)#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- array(mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i))#
}
dist.measure[[i]] <- mapply(function(x,y) sqrt(sum((parameter.estimates[[x]]$mu-pca.components[y,])^2))^2,i,1:nrow(pca.components))
res <- vector()
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) sqrt(sum((parameter.estimates[[x]]$mu-pca.components[y,])^2))^2,i,1:nrow(pca.components))#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) sqrt(sum((parameter.estimates[[x]]$mu-pca.components[y,])^2))^2,i,1:nrow(pcs.for.dragon))#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) sqrt(sum((parameter.estimates[[x]]$mu-pcs.for.dragon[y,])^2))^2,i,1:nrow(pcs.for.dragon))#
}
i
res <- vector("list",length=2)
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) sqrt(sum((parameter.estimates[[x]]$mu-pcs.for.dragon[y,])^2))^2,i,1:nrow(pcs.for.dragon))#
}
for (i in 1:length(parameter.estimates)) {#
res[[i]] <- mapply(function(x,y) mahalanobis(pcs.for.dragon[x,],parameter.estimates[[y]]$mu,parameter.estimates[[y]]$cov),1:nrow(pcs.for.dragon),i)#
}
res
res[[1]]
res[[2]]
?mahalanobis
res1 <- mahalanobis(pcs.for.dragon,parameter.estimates[[1]]$mu,parameter.estimates[[1]]$cov)
identical(res1,res[[1]])
library(rbenchmark)
library(rmarkdown)
render("~/Desktop/DRAGON_markdown.19.07.16.Rmd")
suppressMessages({#
library(splatter)#
library(dragon)#
library(Seurat)#
})
setwd("~/Documents/Vignali Lab/packages/dragon")
sc.params <- newSplatParams(nGenes=1000,batchCells=5000)#
sim.groups <- splatSimulate(params=sc.params,method="groups",group.prob=c(0.10,0.10,0.15,0.15,0.25,0.25),de.prob=c(0.3,0.2,0.2,0.1,0.2,0.1),verbose=F)#
sim.groups
library(devtools)
devtools::use_data(sim.groups)
?use_data
usethis::use_data(sim.groups)
q()
